use std::error::Error;
use std::f32::consts::PI;
use std::fs::File;
use std::io::{Cursor, Read};
use std::path::Path;
use std::process;

use clap::Parser;
use ndarray::prelude::*;
use num_complex::Complex;
use plotters::prelude::*;
use plotters_bitmap::BitMapBackend;

mod args;
mod header;
mod rfi;
mod output;
mod read;
mod fft;
mod analysis;
mod plot;
mod utils;

use args::Args;
use header::parse_header;
use rfi::parse_rfi_ranges;
use output::{output_header_info, output_complex_spectrum, generate_output_names, format_delay_output, format_freq_output};
use read::read_visibility_data;
use fft::{process_fft, process_ifft};
use analysis::analyze_results;
use plot::{plot_fringe, plot_spectrum};

// --- Type Aliases for Clarity ---
type C32 = Complex<f32>;

// --- Main Application Logic ---
fn main() -> Result<(), Box<dyn Error>> {
    let args = Args::parse();

    // --- File and Path Setup ---
    let input_path = &args.input;
    let output_dir = input_path.parent().unwrap_or_else(|| Path::new("."));
    let basename = input_path.file_stem().unwrap().to_str().unwrap();
    let label: Vec<&str> = basename.split('_').collect();

    // --- Read .cor File ---
    let mut file = File::open(input_path)?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;
    let mut cursor = Cursor::new(buffer.as_slice());

    // --- Parse Header ---
    let header = parse_header(&mut cursor)?;
    let bw = header.sampling_speed as f32 / 2.0;
    let rbw = bw / header.fft_point as f32 * 2.0;

    // --- RFI Handling ---
    let rfi_ranges = parse_rfi_ranges(&args.rfi, rbw)?;

    // --- Output Header Information ---
    if args.output {
        output_header_info(&header, &output_dir, basename)?;
    }

    // --- Loop and Processing Setup ---
    let pp = header.number_of_sector;
    let mut length = if args.length == 0 { pp } else { args.length };
    let mut loop_count = if (pp - args.skip) / length <= 0 {
        1
    } else if (pp - args.skip) / length <= args.loop_ {
        (pp - args.skip) / length
    } else {
        args.loop_
    };

    if args.cumulate != 0 {
        if args.cumulate >= pp {
            eprintln!("The specified cumulation length, {} s, is more than the observation time, {} s.", args.cumulate, pp);
            process::exit(1);
        }
        length = args.cumulate;
        loop_count = pp / args.cumulate;
    }

    let mut delay_output_str = String::new();
    let mut freq_output_str = String::new();

    let mut cumulate_len: Vec<f32> = Vec::new();
    let mut cumulate_snr: Vec<f32> = Vec::new();
    let mut cumulate_noise: Vec<f32> = Vec::new();

    // --- Main Processing Loop ---
    for l1 in 0..loop_count {
        let current_length = if args.cumulate != 0 { (l1 + 1) * length } else { length };
        let (mut complex_vec, obs_time, effective_integ_time) = read_visibility_data(&mut cursor, &header, current_length, args.skip, l1, args.cumulate != 0)?;

        // --- Delay and Rate Correction ---
        if args.delay_correct != 0.0 || args.rate_correct != 0.0 {
            let pp_correct = Array::range(args.skip as f32 + 1.0, header.number_of_sector as f32 + 1.0, 1.0);
            let bw_correct = Array::linspace(0.0, (header.sampling_speed / 2 - 1) as f32, header.fft_point as usize / 2);

            let delay_phase_shift: Array1<C32> = bw_correct.mapv(|bw| C32::new(0.0, -2.0 * PI * args.delay_correct * bw / (header.sampling_speed as f32)).exp());

            let rate_phase_shift: Array1<C32> = pp_correct.mapv(|pp| C32::new(0.0, -2.0 * PI * args.rate_correct * pp * effective_integ_time).exp());

            for i in 0..current_length as usize {
                for j in 0..(header.fft_point / 2) as usize {
                    let index = i * (header.fft_point / 2) as usize + j;
                    complex_vec[index] *= delay_phase_shift[j] * rate_phase_shift[i];
                }
            }
        }
        
        if args.cross_output {
            output_complex_spectrum(&complex_vec, &output_dir, basename, &header, current_length)?;
        }

        // --- FFT Processing ---
        let (freq_rate_array, freq_rate_data, padding_length) = process_fft(&complex_vec, current_length, header.fft_point, &rfi_ranges);
        
        // --- IFFT Processing ---
        let (delay_rate_array, delay_rate_2d_data_comp) = process_ifft(&freq_rate_array, header.fft_point, padding_length);

        // --- Analysis and Parameter Calculation ---
        let analysis_results = analyze_results(
            &freq_rate_array,
            &freq_rate_data,
            &delay_rate_array,
            &delay_rate_2d_data_comp,
            &header,
            current_length,
            effective_integ_time,
            &obs_time,
            padding_length,
            &args,
        );

        // --- Output and Plotting ---
        let (fringe_outputname, spectrum_outputname) = generate_output_names(&output_dir, &header, &obs_time, &label, !rfi_ranges.is_empty());

        if !args.frequency {
            let delay_output_line = format_delay_output(&analysis_results, &label);
            if l1 == 0 {
                let header_str = "#*************************************************************************************************************************************************\n".to_string()
                           + "#      Epoch        Label    Source     Length    Amp      SNR     Phase     Noise-level            YAMAGU32-azel            YAMAGU34-azel        \n"
                           + "#                                        [s]      [%]               [deg]     1-sigma[%]    az[deg]  el[deg]  hgt[m]    az[deg]  el[deg]  hgt[m]  \n"
                           + "#*************************************************************************************************************************************************\n";
                print!("{}", header_str);
                delay_output_str += &header_str;
            }
            print!("{}", delay_output_line);
            delay_output_str += &delay_output_line;

            if args.cumulate != 0 {
                cumulate_len.push(current_length as f32);
                cumulate_snr.push(analysis_results.delay_snr);
                cumulate_noise.push(analysis_results.delay_noise);
            }

            if l1 == loop_count - 1 && args.output {
                let delay_txt_path = format!("{}.txt", fringe_outputname);
                std::fs::write(delay_txt_path, &delay_output_str)?;
            }
        } else {
            let freq_output_line = format_freq_output(&analysis_results, &label);
            if l1 == 0 {
                let header_str = "#*************************************************************************************************************************************************************\n".to_string()
                           + "#      Epoch        Label    Source     Length    Amp      SNR     Phase     Frequency     Noise-level        YAMAGU32-azel             YAMAGU34-azel         \n"
                           + "#                                        [s]      [%]              [deg]     1-sigma[%]                 az[deg]  el[deg]  hgt[m]   az[deg]  el[deg]  hgt[m]   \n"
                           + "#*************************************************************************************************************************************************************\n";
                print!("{}", header_str);
                freq_output_str += &header_str;
            }
            print!("{}", freq_output_line);
            freq_output_str += &freq_output_line;

            if l1 == loop_count - 1 && args.output {
                let freq_txt_path = format!("{}.txt", spectrum_outputname);
                std::fs::write(freq_txt_path, &freq_output_str)?;
            }
        }

        if args.plot && args.cumulate == 0 {
            if !args.frequency {
                plot_fringe(&analysis_results, &fringe_outputname, &header)?;
            } else {
                plot_spectrum(&analysis_results, &spectrum_outputname, &header)?;
            }
        }
    }

    if args.cumulate != 0 {
        let cumulate_output_dir = output_dir.join("cumulate");
        std::fs::create_dir_all(&cumulate_output_dir)?;
        let cumulate_filename = format!("{}_{}_cumulate.png", basename, header.source_name);
        let cumulate_filepath = cumulate_output_dir.join(cumulate_filename);
        
        let root = BitMapBackend::new(&cumulate_filepath, (1200, 900)).into_drawing_area();
        root.fill(&WHITE)?;

        let mut chart = ChartBuilder::on(&root)
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(50)
            .build_cartesian_2d(cumulate_len[0]..*cumulate_len.last().unwrap(), 0f32..*cumulate_snr.iter().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap() * 1.1)?;

        chart.configure_mesh()
            .x_desc("Integration Time [s]")
            .y_desc("S/N")
            .draw()?;

        chart.draw_series(LineSeries::new(cumulate_len.iter().zip(cumulate_snr.iter()).map(|(x, y)| (*x, *y)), &RED))?;

        root.present()?;
    }
    
    Ok(())
}